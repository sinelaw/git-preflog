#!/usr/bin/python

import subprocess
import os
import datetime
import time
import itertools

from babel.dates import format_timedelta

def iter_files(base, files=True):
    base_n = len(base) + 1
    def recurse(path):
        for name in os.listdir(path):
            pathname = os.path.join(path, name)
            if os.path.isdir(pathname):
                for x in recurse(pathname):
                    yield x
            if os.path.isfile(pathname):
                if files:
                    yield pathname[base_n:]
    for y in recurse(base):
        yield y

def title(now, key, r):
    delta = datetime.timedelta(seconds=(key - now))
    return "%s %s ago:" % (r, format_timedelta(delta, locale='en_US'), )

def process_key(by_timestamp, now, key):
    change_type = None
    is_fetch = True
    is_push = True
    fetch_remote = None
    push_remote = None
    for (ref, details, action) in by_timestamp[key]:
        if not action.startswith('fetch: '):
            is_fetch = False
        else:
            (remote, _) = ref.split('/', 1)
            if fetch_remote is None:
                fetch_remote = remote
            elif fetch_remote != remote:
                fetch_remote = -1
        if not action.startswith('update by push'):
            is_push = False
        else:
            (remote, _) = ref.split('/', 1)
            if push_remote is None:
                push_remote = remote
            elif push_remote != remote:
                push_remote = -1
    if is_fetch:
        change_type = 'fetch'
    if is_push:
        change_type = 'push'
    if change_type == 'fetch':
        t = title(now, key, "Fetch from %s" % (fetch_remote, ))
        for (ref, details, action) in by_timestamp[key]:
            (_, branch) = ref.split('/', 1)
            flag = ' '
            rangestr = '..'
            suffix = ''
            if action == 'fetch: forced-update':
                rangestr = '...'
                suffix = "  (forced update)"
                flag = "+"
            range_total = "%s%s%s" % (details[0][:12], rangestr, details[1][:12])
            if action == 'fetch: storing head':
                range_total = '[new branch]'
                flag = "*"
            v = " %s %-30s %s -> %s%s" % (flag, range_total, branch, ref, suffix)
            yield (t, v)
            # print (ref, details, action)
    elif change_type == 'push':
        t = title(now, key, "Push to %s" % (push_remote, ))
        for (ref, details, action) in by_timestamp[key]:
            (_, branch) = ref.split('/', 1)
            yield (t, "   " + branch)
    else:
        #t = title(now, key, "<unhandled reflog change>")
        #yield (t, "")
        return

def main():
    git_dir = subprocess.check_output("git rev-parse --git-dir", shell=True).strip()
    base_dir = os.path.join(git_dir, "logs", "refs", "remotes")
    by_timestamp = {}
    for ref in iter_files(base_dir):
        for line in open(os.path.join(base_dir, ref)).readlines():
            [details, action] = line.strip().split('\t')
            details = details.split(' ')
            ts = int(details[-2], 10)
            if ts not in by_timestamp:
                by_timestamp[ts] = []
            by_timestamp[ts].append((ref, details, action))
    tses = by_timestamp.keys()
    for key, val in by_timestamp.iteritems():
        val.sort()
    tses.sort()
    now = time.time()

    def gather_results():
        for key in tses:
            for (title, value) in process_key(by_timestamp, now, key):
                yield (title, value)

    for (title, tvs) in itertools.groupby(gather_results(), lambda (t, v): t):
        print ""
        print title
        values = sorted(set(v for (_,v) in tvs))
        for value in values:
            print value
            # print datetime.datetime.strptime(ts, "%t %z")

if __name__ == "__main__":
    main()
